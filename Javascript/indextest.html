<!DOCTYPE html>
<meta charset="utf-8">
<svg width="1000" height="500"></svg>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script>


var colors = ['#779edd','#dd7a5f','#92b74d','#6189a5','#e09b3a']

// dimensions and margins
var svg = d3.select("svg"),
    width = +svg.attr("width"),
    height = +svg.attr("height"),
width = 0.8*width;
height = 0.8*height;
var margin = {top: (0.1*width), right: (0.1*width), bottom: (0.1*width), left: (0.1*width)};

// create a clipping region 
svg.append("defs").append("clipPath")
	.attr("id", "clip")
  	.append("rect")
    .attr("width", width)
    .attr("height", height);
  


var Xmax=0;
var Ymax=0;

var xScale = d3.scaleLinear()
  	.domain([0,Xmax])
  	.range([0, width]);
var yScale = d3.scaleLinear()
    .domain([0, Ymax])
    .range([height, 0]);
	
	
	// 7. d3's line generator
var line = d3.line()
    .x(function(d) { return xScale(d.x); }) // set the x values for the line generator
    .y(function(d) { return yScale(d.y); }) // set the y values for the line generator 
    .curve(d3.curveMonotoneX) // apply smoothing to the line
	
  // create axis objects
var xAxis = d3.axisBottom(xScale)
    .ticks(20, "s");
var yAxis = d3.axisLeft(yScale)
    .ticks(20, "s");

// Draw Datapoints
var points_g = svg.append("g")
  .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')')
  .attr("clip-path", "url(#clip)")
  .classed("points_g", true);

//data = genRandomData (n, max);



var groups = {};
//var data = [];
var gX;
var gY;
d3.csv("https://raw.githubusercontent.com/RollerVincent/GoBI/master/Resources/plot_data/exon_skipping/test_plot_exons.csv", function(csv) {
	var data=csv;	
	data.forEach(function(d){
		if(!Object.keys(groups).includes(d.group)){
			groups[d.group] = [];
		}
		groups[d.group].push(d);
	  	d.x = parseInt(d.x);
	  	if (d.x>Xmax){
		 	 Xmax=d.x;
	 	}
	  	d.y = parseInt(d.y);
	  	if (d.y>Ymax){
		 	 Ymax=d.y;
	 	}
	});
	
  	yScale.domain([0, Ymax]);
  	xScale.domain([0, Xmax]);
  
  // Draw Axis
  	gX = svg.append('g')
    	.attr('transform', 'translate(' + margin.left + ',' + (margin.top + height) + ')')
    	.call(xAxis);
  	gY = svg.append('g')
    	.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')')
    	.call(yAxis);
  
	var keys=Object.keys(groups);
	for(var i in keys){
		points_g.append('path')
  		.attr('d', line(groups[keys[i]]))
  		.attr('stroke', colors[keys.indexOf(keys[i])%colors.length])
  		.attr('stroke-width', 3)
  		.attr('fill', 'none')
		.attr('group', keys[i]);
	}
	
/*	points_g.selectAll("circle").data(data)
	.enter().append("circle")
	      .attr('cx', function(d) {
			  return xScale(d.x);
		  })
	      .attr('cy', function(d) {
			  return yScale(d.y);
		  })
	      .attr('r', 1)
		  .attr('fill',function(d){
			  return colors[Object.keys(groups).indexOf(d.group)%colors.length];
		  });*/
		  
});

// Pan and zoom
var zoom = d3.zoom()
    .scaleExtent([0, 500])
    .extent([[0, 0], [width, height]])
    .on("zoom", zoomed);

svg.append("rect")
    .attr("width", width)
    .attr("height", height)
    .style("fill", "none")
    .style("pointer-events", "all")
    .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')')
    .call(zoom);


function zoomed() {
	// create new scale ojects based on event
    var new_xScale = d3.event.transform.rescaleX(xScale);
    var new_yScale = d3.event.transform.rescaleY(yScale);
	// update axes
    gX.call(xAxis.scale(new_xScale));
    gY.call(yAxis.scale(new_yScale));
	
	line
	 .x(function(d) { return new_xScale(d.x); }) // set the x values for the line generator
     .y(function(d) { return new_yScale(d.y); });
	 
	points_g.selectAll('path').each(function(d,i) {
		d3.select(this).attr('d', line(groups[d3.select(this).attr('group')]));
	});
 
   // points_g.selectAll('circle').data(data)
     //.attr('cx', function(d) {return new_xScale(d.x)})
     //.attr('cy', function(d) {return new_yScale(d.y)});
	 
}
</script>